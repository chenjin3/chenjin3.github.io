---
layout: post
title: 面向对象与函数式编程设计模式 
published: true
---


## 引子

坊间传闻很多程序员之间的鄙视链，我们虽然可以不以为然，但也常常不能免俗。在今天的面向对象设计与函数式编程的上下文中套用一下鄙视链的逻辑，可能是懂 Functional Programming 的工程师鄙视老是把设计模式挂在嘴边的工程师，老是把设计模式挂在嘴边的工程师鄙视会说「你这样写就不 OO 了啊」的工程师，会说「你这样写就不 OO 了啊」的工程师鄙视会说「蛤？什么面向对象？不是把重复的 code 写成一个 function 就好了吗？」的工程师，会说「蛤？什么面向对象？不是把重复的 code 写成一个 function 就好了吗？」的工程师鄙视把同一段 code 到处复制贴上的工程师。那么是么是面向对象，什么是函数式编程？他们之间又有怎样的关系呢？且看下文。

## 概念

什么是面向对象？看下维基百科的定义： 面向对象编程（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。

什么是函数式编程？继续摘抄维基百科的定义：函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入和输出。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

## 面向对象与函数式编程对比（OO VS FP）

从起源来看，面向对象来源于生物学，将程序用对象的形式来表示。而函数式编程来源于数学，具体说是来源于[lambda演算](https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97)。
而OO和FP的被人们广泛应用则是分别是因为GUI应用和并行计算的兴起。从程序的组织形式上看，OO和FP编程范式的程序的基本单位分别是对象和函数，OO是指令式编程，而FP是声明式编程。OO的代表语言有C++，Java，Objective-C， C#，而FP的代表语言有Haskell，Scheme，Erlang，Ocaml，而另外一些编程语言（如JavaScript和Python）既可以采用面向对象编程又可以采用函数式编程范型。

## 面向对象编程核心

### OO三大特性
对象是现实世界的模型。面向对象编程的三个基本要素是封装、继承和多态。
封装即利用抽象数据类型将数据和对数据的操作包装在一起，使其构成一个不可分割的独立体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外提供的接口来访问该对象。
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用用父类的属性和功能。通过使用继承我们能够非常方便地复用以前的代码，提高开发效率。
所谓多态是指向在继承中，子类重写了父类的方法，而父类数据类型的引用指向子类的对象（向上转型），使得父类数据类型的引用可以用统一的代码实现不同的逻辑，表现出不同的行为。

### OO设计原则

除了高内聚、低耦合、关注点分离、模块化开发等软件设计的一些通用原则外，面向对象编程一般还遵循7个重要的原则。即SOLID原则（单一职责原则、开放封闭原则、里氏替换原则、依赖导致原则、接口分离原则），最少知识原则（迪米特法则）和合成复用原则。

#### 单一职责原则(Single Responsibility Principle)
一个对象应该只包含单一定职责，并且该职责被完整地封装在一个类中。    

#### 开闭原则(Open Closed Principle)  
一个软件实体应当对扩展开放，对修改关闭，也就是说在设计一个模块或类的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。 

#### 里氏代换原则(Liskov Substitution Principle)  
所有引用基类的地方必须能够透明地使用其子类地对象。也就是继承必须确保基类所拥有的性质在子类中仍然成立。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

#### 依赖倒转原则(Dependency Inversion Principle) 
依赖接口编程，不要依赖具体类的实现编程。

#### 接口隔离原则(Interface Segregation Principle)  
客户端不应该依赖那些它不需要地接口。使用多个专门的客户端接口比使用单一的宽泛用途的接口要好。如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。

#### 迪米特法则(Law of Demeter) 
也叫最少知识原则(Least Knowledge Principle)，每一个模块对其他的模块都只有最少的知识，而且局限于那些与本模块密切相关的软件模块。对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。在类的划分上，应当创建有弱耦合的类,类之间的耦合越弱，就越有利于复用。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。在对其它对象的引用上，一个类对其它对象的引用应该降到最低。

#### 组合复用原则(Composite Reuse Principle)
尽量使用对象组合(Has-A)，而不是继承(Is-A)来达到复用的目的。因为组合这种复用是黑箱复用，成员对象的内部细节是新对象所看不见的。这种复用也可以在运行时间动态进行，新对象可以动态的引用与成员对象类型相同的对象，将职责委托给具有相同超类型的对象。 而继承复用中从超类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。

### OO设计模式
在编程中，设计模式的引入可以获得遵循上文所述的设计原则的软件架构，而代价是增加了代码的复杂度。
就像信耶稣的人都要读圣经，信OO的人都要读四人组(GOF)的《设计模式》。GOF根据设计模式的目标将模式分为三类：创建型、结构型和行为型。

#### 创建型模式

创建型模式设计对象的实例化，这类模式的特点是，不让用户依赖于对象的创建方式，避免用户直接使用new运算符创建对象。

GOF的23中模式中的下列5种模式属于创建型模式：

1. [工厂方法模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#工厂方法模式)：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
2. [抽象工厂模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#抽象工厂模式)：提供一个创建一系列或相互依赖对象的接口，而不需要明确指定具体类。
3. 建造者/生成器模式(Builder Pattern)：封装一个产品的构造过程，并允许按步骤构造。将一个复杂对象的创建过程封装起来，向客户隐藏了产品内部的表现。允许对象通过多个步骤来创建，并且可以改变过程（这个只有一个步骤的工厂模式不同）。产品的实现可以被替换，因为客户只能看到一个抽象的接口。建造者模式包含如下角色：
Builder（抽象建造者）
ConcreteBuilder（具体建造者）
Director（指挥者）
Product（产品角色）。
类图如下：![生成器模式](/images/designPattern/Builder.jpg)

4. [原型模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#原型模式)：将原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
5. [单例模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#单例模式)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### 结构型模式

结构型模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式设计如何合理地使用继承机制；和对象有关的结构型模式涉及如何合理地使用对象组合机制。

GOF的23种模式中的下列7种模式属于创建型模式：

1. [适配器模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#适配器模式)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。
2. [组合模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#组合模式)：将对象组合成树形结构以表示”部分-整体“的层次结构。Composite模式使用户对单个对象和组合对象的使用具有一致性。组合模式可以应用于GUI中的父子组件、文件夹和文件的嵌套关系的抽象。
   
3. [代理模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#代理模式)：为其他对象提供一种代理以控制对这个对象的访问。代理模式包含如下角色：Subject（抽象主题角色）, Proxy（代理主题角色）, RealSubject（真实主题角色）。类图如下：![生成器模式](/images/designPattern/Proxy.jpg)
4. [享元模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#享元模式)：运用共享技术有效地支持大量细粒度的对象, 一般用来解决内存占用高等性能问题。
5. [外观模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#外观模式)：为系统的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使这一子系统更加容易使用。
6. [桥接模式](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。Bridge模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变。桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统中类的个数急剧增加。桥接模式包含如下角色：
Abstraction（抽象类）
RefinedAbstraction（扩充的抽象类）
Implementor（实现类接口）
ConcreteImplementor（具体实现类）。
类图如下：![桥接模式](/images/designPattern/Bridge.jpg)
   
7. [装饰者模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#装饰者模式)：以对客户透明的方式动态地给一个对象附加上更多的责任，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，通过在对象中嵌入其他类（我们称这个嵌入的对象为装饰器）的成员属性的方式将对象的功能加以扩展。

#### 行为型模式

行为模式涉及怎样合理地设计对象之间的交互通信，以及怎样合理为对象分配职责，让设计富有弹性，易维护和易复用。

GOF的23种模式中的下列11种模式属于创建型模式：
1. [观察者模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#观察者模式)：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。
   
2. [迭代器模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#迭代器模式)：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
   
3. [状态模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#状态模式)：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
   
4. [中介者模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#中介者模式)：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

5. [命令模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#命令模式)：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
   
6. [策略模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#策略模式)：定义一系列算法，把它们一个个封装起来，并且可使它们可以相互替换。策略模式使算法可独立于使用它的客户而变化。
   
7. [责任链模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/#职责链模式 "职责链模式与电商预购应用")：又名职责链模式，它使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

8. 解释器模式：给定一个语言，定义它文法的一种表示，并定义一个解释器，解释器会将每个语法规则表示成一个类，这个解释器使用该表示来解释给定语言中的语句。

9. 备忘录模式：在不破坏封装性的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。Memento模式在前端JS中经常用于数据缓存. 比如一个分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，可以直接使用缓存里的数据而无需再次请求服务器。
实现比较简单，伪代码：
```
var Page = function(){
   var page = 1,
      cache = {},
      data;
   return function( page ){
      if ( cache[ page ] ){
               data =  cache[ page ];
               render( data );
      }else{
               Ajax.send( 'api.xx.com/xxx', function( data ){
                   cache[ page ] = data;
                   render( data );
               })
      }
    }
}()
```

10. [模板方法模式](/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C/#模板方法模式)：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以不改变一个算法的结构即可定义该算法的某些特定步骤。
    
11. 访问者模式：访问者模式在GOF的23中设计模式中可能是比较难于理解的一个，它表示一个作用于某个结构对象集合中的各元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

我们在使用一些操作对不同的对象进行处理时，往往会根据不同的对象选择不同的处理方法和过程。在实际的代码过程中，我们可以发现，如果让所有的操作分散到各个对象中，整个系统会变得 难以维护和修改。且增加新的操作通常都要修改所有的类。
因此，为了解决这个问题，我们可以将每一个类中的相关操作提取出来，包装成一个独立的对象，这个对象我们就称为访问者（Visitor）。利用访问者，对访问的元素进行某些操作时，只需将此对象作为参数传递给当前访问者，然后，访问者会依据被访问者的具体信息，进行相关的操作。

一般来说其中包含五个角色，
Abstract Visitor（抽象访问者）：声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。
Visitor(访问者)：实现抽象访问者所声明的方法，它影响到访问者访问到一个元素类后要做什么事情。
Abstract Element（抽象元素类）：声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。
Element（元素类）：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。
Structure Object（结构对象）：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等。这个角色在项目中通常是可选的。

在JavaScript这类弱类型语言中，很多方法里都不做对象的类型检测，而是只关心这些对象能做什么。因此我们不需要作为接口描述的两个抽象角色，其代码实现如下：

```
// 访问者
function Visitor() {
   this.visit = function( concreteElement ) {
      concreteElement.doSomething();
   }
}
// 元素类
function ConceteElement() {
   this.doSomething = function() {
      console.log("这是一个具体元素");
   }
   this.accept = function( visitor ) {
      visitor.visit(this);
   }
}
// Client
var ele = new ConceteElement();
var v = new Visitor();
ele.accept( v );
```

其实，在js这种基于鸭子类型的语言中，访问者模式几乎是原生的实现, 所以我们可以利用apply和call毫不费力的使用访问者模式。Array构造器的prototype上的方法就被特意设计成了访问者，这些方法不对this的数据类型做任何校验。例如给一个Object对象增加push,pop方法，我们可以这样实现：

```
function Visitor() {
   this.push = function(ele, ...args) { //visit function 
            return Array.prototype.push.apply(ele, args); 
   }
   this.pop = function() {
            return Array.prototype.pop.apply(ele);
   }
};

let v = new Visitor();
let ele = {};

v.push(ele, 1, 2, 3, 4);
console.log(ele); // { '0': 1, '1': 2, '2': 3, '3': 4, length: 4 }

ele.pop();
console.log(ele); //{ '0': 1, '1': 2, '2':3, length: 3 }
```


## 参考资料
1. 《设计模式—可复用面向对象软件的基础》，作者: [美] Erich Gamma等，机械工业出版社
2. 《Head First 设计模式》作者: 弗里曼，中国电力出版社
3. 《JavaScript设计模式与开发实践》 作者:曾探，人民邮电出版社
4. 《设计模式之禅》作者：秦小波，机械工业出版社. 2014
5. [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html)
